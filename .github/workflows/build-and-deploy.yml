name: Build, Push and Deploy

on:
  # Push'ta otomatik Ã§alÄ±ÅŸÄ±r
  push:
    branches: [main, master]
  # Manuel de Ã§alÄ±ÅŸtÄ±rÄ±labilir
  workflow_dispatch:
    inputs:
      action:
        description: 'What to do'
        required: true
        default: 'build-and-deploy'
        type: choice
        options:
          - build-only
          - deploy-only
          - build-and-deploy

env:
  REGISTRY: docker.io
  DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
  ENVIRONMENT: production

jobs:
  # ============================================================================
  # JOB 1: Build Images
  # ============================================================================
  build:
    name: 'Build Docker Images'
    runs-on: ubuntu-latest
    # Push'ta veya manuel build-and-deploy/build-only seÃ§ildiÄŸinde Ã§alÄ±ÅŸÄ±r
    if: github.event_name == 'push' || github.event.inputs.action != 'deploy-only'
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and Push auth-api
        uses: docker/build-push-action@v5
        with:
          context: ./auth-api
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/auth-api:${{ github.sha }}
            ${{ secrets.DOCKER_USERNAME }}/auth-api:latest

      - name: Build and Push product-api
        uses: docker/build-push-action@v5
        with:
          context: ./product-api
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/product-api:${{ github.sha }}
            ${{ secrets.DOCKER_USERNAME }}/product-api:latest

      - name: Build and Push gateway
        uses: docker/build-push-action@v5
        with:
          context: ./gateway
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/gateway:${{ github.sha }}
            ${{ secrets.DOCKER_USERNAME }}/gateway:latest

      - name: Build and Push ecommerce
        uses: docker/build-push-action@v5
        with:
          context: ./ecommerce
          push: true
          tags: |
            ${{ secrets.DOCKER_USERNAME }}/ecommerce:${{ github.sha }}
            ${{ secrets.DOCKER_USERNAME }}/ecommerce:latest

  # ============================================================================
  # JOB 2: Deploy to k3s (Build tamamlandÄ±ktan sonra)
  # ============================================================================
  deploy:
    name: 'Deploy to k3s'
    runs-on: ubuntu-latest
    needs: [build]  # Build bittikten sonra baÅŸlar
    if: always() && needs.build.result == 'success'
    env:
      DEPLOY_ENV: ${{ github.event.inputs.environment || 'production' }}
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: '3.13.0'

      - name: Setup SSH and Kubeconfig
        run: |
          mkdir -p ~/.ssh ~/.kube
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          
          MASTER_IP="${{ secrets.MASTER_IP }}"
          ssh-keyscan -H $MASTER_IP >> ~/.ssh/known_hosts 2>/dev/null || true
          
          # Download kubeconfig from master
          ssh -o StrictHostKeyChecking=no root@$MASTER_IP \
            "cat /etc/rancher/k3s/k3s.yaml" | \
            sed "s/127.0.0.1/$MASTER_IP/g" > ~/.kube/config
          
          chmod 600 ~/.kube/config

      - name: Verify cluster connection
        run: |
          kubectl cluster-info
          kubectl get nodes
          # API server baÄŸlantÄ±sÄ±nÄ± test et
          kubectl get namespaces --request-timeout=30s
          
      - name: Check Storage Classes
        run: |
          echo "ðŸ“¦ Mevcut Storage Classes:"
          kubectl get storageclass || echo "Storage class bulunamadÄ±"
          echo ""
          echo "VarsayÄ±lan storage class:"
          kubectl get storageclass -o jsonpath='{.items[?(@.metadata.annotations.storageclass\.kubernetes\.io/is-default-class=="true")].metadata.name}' || echo "VarsayÄ±lan storage class yok"

      - name: Create namespace
        run: |
          kubectl create namespace ${{ env.DEPLOY_ENV }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Create Docker Registry Secret
        run: |
          kubectl create secret docker-registry regcred \
            --docker-server=docker.io \
            --docker-username=${{ secrets.DOCKER_USERNAME }} \
            --docker-password=${{ secrets.DOCKER_PASSWORD }} \
            --namespace=${{ env.DEPLOY_ENV }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Helm Dependency Update
        run: |
          cd aws-k8s-helm
          helm dependency update

      - name: Verify Required Secrets
        run: |
          echo "ðŸ” Gerekli secrets kontrol ediliyor..."
          REQUIRED_SECRETS=(
            "AUTH_POSTGRES_PASSWORD"
            "PRODUCT_POSTGRES_PASSWORD"
            "JWT_SECRET"
            "AUTH_JWT_SECRET"
            "AUTH_JWT_REFRESH_SECRET"
          )
          
          MISSING_SECRETS=()
          for secret in "${REQUIRED_SECRETS[@]}"; do
            if [[ -z "${!secret}" ]]; then
              MISSING_SECRETS+=("$secret")
            fi
          done
          
          if [[ ${#MISSING_SECRETS[@]} -gt 0 ]]; then
            echo "âŒ Eksik secrets bulundu: ${MISSING_SECRETS[*]}"
            echo "LÃ¼tfen GitHub Repository Settings > Secrets and variables > Actions bÃ¶lÃ¼mÃ¼nden bu secrets'larÄ± ekleyin."
            exit 1
          fi
          
          echo "âœ… TÃ¼m gerekli secrets mevcut"
        env:
          AUTH_POSTGRES_PASSWORD: ${{ secrets.AUTH_POSTGRES_PASSWORD }}
          PRODUCT_POSTGRES_PASSWORD: ${{ secrets.PRODUCT_POSTGRES_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          AUTH_JWT_SECRET: ${{ secrets.AUTH_JWT_SECRET }}
          AUTH_JWT_REFRESH_SECRET: ${{ secrets.AUTH_JWT_REFRESH_SECRET }}

      - name: Helm Deploy
        run: |
          cd aws-k8s-helm
          
          # values.yaml kullanÄ±lÄ±yor, hassas bilgiler GitHub Secrets'tan gelecek
          IMAGE_TAG="${{ github.sha }}"
          
          echo "ðŸš€ Helm deployment baÅŸlatÄ±lÄ±yor..."
          echo "Image Tag: ${IMAGE_TAG}"
          echo "Namespace: ${{ env.DEPLOY_ENV }}"
          
          # Metrics server uyarÄ±larÄ±nÄ± bastÄ±rmak iÃ§in
          export KUBECTL_INTERACTIVE_TIMEOUT=30s
          
          # Storage class'Ä± kontrol et ve ayarla
          DEFAULT_STORAGE_CLASS=$(kubectl get storageclass -o jsonpath='{.items[?(@.metadata.annotations.storageclass\.kubernetes\.io/is-default-class=="true")].metadata.name}' 2>/dev/null || echo "")
          if [ -z "$DEFAULT_STORAGE_CLASS" ]; then
            # VarsayÄ±lan yoksa, ilk storage class'Ä± kullan veya local-path dene
            STORAGE_CLASS=$(kubectl get storageclass -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "local-path")
          else
            STORAGE_CLASS="$DEFAULT_STORAGE_CLASS"
          fi
          
          echo "ðŸ“¦ Mevcut Storage Class: ${STORAGE_CLASS}"
          
          # Mevcut StatefulSet'leri kontrol et
          AUTH_STS_EXISTS=$(kubectl get statefulset -n ${{ env.DEPLOY_ENV }} aws-k8s-helm-postgresql-auth -o name 2>/dev/null || echo "")
          PRODUCT_STS_EXISTS=$(kubectl get statefulset -n ${{ env.DEPLOY_ENV }} aws-k8s-helm-postgresql-product -o name 2>/dev/null || echo "")
          
          if [ -n "$AUTH_STS_EXISTS" ] || [ -n "$PRODUCT_STS_EXISTS" ]; then
            echo "âš ï¸  Mevcut StatefulSet'ler bulundu."
            echo "â„¹ï¸  StatefulSet storage class deÄŸiÅŸtirilemez, mevcut PVC'ler korunacak."
            echo "â„¹ï¸  Sadece diÄŸer ayarlar gÃ¼ncellenecek, veriler korunacak."
          else
            echo "âœ… Yeni deployment, values.yaml'daki storage class kullanÄ±lacak."
          fi
          
          # Helm deployment - --wait olmadan, pod'lar arka planda baÅŸlatÄ±lÄ±r
          # Ã–NEMLÄ°: StatefulSet storage class override yapÄ±lmÄ±yor Ã§Ã¼nkÃ¼ deÄŸiÅŸtirilemez
          # Mevcut StatefulSet'ler varsa, storage class deÄŸiÅŸmeyecek ama veriler korunacak
          helm upgrade --install aws-k8s-helm . \
            --namespace=${{ env.DEPLOY_ENV }} \
            --values=values.yaml \
            --set global.imageRegistry=docker.io/${{ secrets.DOCKER_USERNAME }} \
            --set authApi.image.tag="${IMAGE_TAG}" \
            --set productApi.image.tag="${IMAGE_TAG}" \
            --set gateway.image.tag="${IMAGE_TAG}" \
            --set ecommerce.image.tag="${IMAGE_TAG}" \
            --set authApi.env.POSTGRES_PASSWORD="${{ secrets.AUTH_POSTGRES_PASSWORD }}" \
            --set productApi.env.POSTGRES_PASSWORD="${{ secrets.PRODUCT_POSTGRES_PASSWORD }}" \
            --set productApi.env.JWT_SECRET="${{ secrets.JWT_SECRET }}" \
            --set postgresql-auth.auth.postgresPassword="${{ secrets.AUTH_POSTGRES_PASSWORD }}" \
            --set postgresql-auth.auth.password="${{ secrets.AUTH_POSTGRES_PASSWORD }}" \
            --set postgresql-product.auth.postgresPassword="${{ secrets.PRODUCT_POSTGRES_PASSWORD }}" \
            --set postgresql-product.auth.password="${{ secrets.PRODUCT_POSTGRES_PASSWORD }}" \
            --set secrets.authApi.jwtSecret="${{ secrets.AUTH_JWT_SECRET }}" \
            --set secrets.authApi.jwtRefreshSecret="${{ secrets.AUTH_JWT_REFRESH_SECRET }}" \
            --set secrets.authApi.databaseUrl="${{ secrets.AUTH_DATABASE_URL }}" \
            --set secrets.productApi.databaseUrl="${{ secrets.PRODUCT_DATABASE_URL }}" \
            --force 2>&1 | tee /tmp/helm-output.log || {
              HELM_ERROR=$(cat /tmp/helm-output.log)
              if echo "$HELM_ERROR" | grep -q "StatefulSet.*is invalid.*spec.*Forbidden"; then
                echo ""
                echo "âš ï¸  StatefulSet storage class hatasÄ± tespit edildi."
                echo "â„¹ï¸  Mevcut StatefulSet'ler farklÄ± storage class kullanÄ±yor."
                echo "â„¹ï¸  Verileri korumak iÃ§in StatefulSet'ler deÄŸiÅŸtirilmiyor."
                echo "â„¹ï¸  Sadece diÄŸer servisler gÃ¼ncelleniyor..."
                
                # StatefulSet'leri atlayarak diÄŸer servisleri gÃ¼ncelle
                helm upgrade --install aws-k8s-helm . \
                  --namespace=${{ env.DEPLOY_ENV }} \
                  --values=values.yaml \
                  --set global.imageRegistry=docker.io/${{ secrets.DOCKER_USERNAME }} \
                  --set authApi.image.tag="${IMAGE_TAG}" \
                  --set productApi.image.tag="${IMAGE_TAG}" \
                  --set gateway.image.tag="${IMAGE_TAG}" \
                  --set ecommerce.image.tag="${IMAGE_TAG}" \
                  --set authApi.env.POSTGRES_PASSWORD="${{ secrets.AUTH_POSTGRES_PASSWORD }}" \
                  --set productApi.env.POSTGRES_PASSWORD="${{ secrets.PRODUCT_POSTGRES_PASSWORD }}" \
                  --set productApi.env.JWT_SECRET="${{ secrets.JWT_SECRET }}" \
                  --set postgresql-auth.enabled=false \
                  --set postgresql-product.enabled=false \
                  --set secrets.authApi.jwtSecret="${{ secrets.AUTH_JWT_SECRET }}" \
                  --set secrets.authApi.jwtRefreshSecret="${{ secrets.AUTH_JWT_REFRESH_SECRET }}" \
                  --set secrets.authApi.databaseUrl="${{ secrets.AUTH_DATABASE_URL }}" \
                  --set secrets.productApi.databaseUrl="${{ secrets.PRODUCT_DATABASE_URL }}"
                
                echo ""
                echo "âœ… DiÄŸer servisler gÃ¼ncellendi. PostgreSQL StatefulSet'leri korundu."
                echo "â„¹ï¸  PostgreSQL'leri gÃ¼ncellemek iÃ§in manuel olarak scale down/up yapabilirsiniz."
              else
                echo "âŒ Helm deployment baÅŸarÄ±sÄ±z oldu:"
                echo "$HELM_ERROR"
                exit 1
              fi
            }
          
          echo "âœ… Helm deployment tamamlandÄ±. Pod'lar arka planda baÅŸlatÄ±lÄ±yor..."

      - name: Check Pod Status
        if: always()
        run: |
          # Metrics server uyarÄ±larÄ±nÄ± bastÄ±rmak iÃ§in
          export KUBECTL_INTERACTIVE_TIMEOUT=30s
          
          echo "## ðŸ“Š Pod DurumlarÄ±" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n ${{ env.DEPLOY_ENV }} -o wide --request-timeout=30s 2>/dev/null >> $GITHUB_STEP_SUMMARY || kubectl get pods -n ${{ env.DEPLOY_ENV }} -o wide >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ðŸ” Son Events" >> $GITHUB_STEP_SUMMARY
          kubectl get events -n ${{ env.DEPLOY_ENV }} --sort-by='.lastTimestamp' --request-timeout=30s 2>/dev/null | tail -30 >> $GITHUB_STEP_SUMMARY || kubectl get events -n ${{ env.DEPLOY_ENV }} --sort-by='.lastTimestamp' | tail -30 >> $GITHUB_STEP_SUMMARY || true

      - name: Show Pod Logs (if failed)
        if: failure()
        run: |
          echo "## ðŸ“‹ Pod LoglarÄ± (Hata Durumunda)" >> $GITHUB_STEP_SUMMARY
          for pod in $(kubectl get pods -n ${{ env.DEPLOY_ENV }} -o jsonpath='{.items[*].metadata.name}'); do
            echo "### Pod: $pod" >> $GITHUB_STEP_SUMMARY
            kubectl logs -n ${{ env.DEPLOY_ENV }} $pod --tail=50 >> $GITHUB_STEP_SUMMARY 2>&1 || true
            echo "" >> $GITHUB_STEP_SUMMARY
          done

      - name: Verify Deployment
        run: |
          echo "## ðŸš€ Deployment Complete!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n ${{ env.DEPLOY_ENV }} >> $GITHUB_STEP_SUMMARY
          kubectl get svc -n ${{ env.DEPLOY_ENV }} >> $GITHUB_STEP_SUMMARY
